---
id: LC450
title: LC450. Delete Node in a BST
sidebar_label: LC450. Delete Node in a BST
tags: ['Patterns/Tree', 'DataStructure/Tree']
---

## Problem Description

Source: https://leetcode.com/problems/delete-node-in-a-bst/

Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference of the updated BST. 

For example:
```
Input:   5            Output:  5
        / \                   / \
       3   6    -------->    3   6
      / \   \               /     \
     2   4   7             2       7

Target: 4
```

## Solution

### High level strategy
There are two steps in deleting a node in a binary search tree:
1. Find the node to delete.
2. Delete the node.

To find the node we want to delete, we can make use of the binary search tree invariant. Namely, that the right child of current node will always be greater than the current node, and the left child of the current node will always be lesser than the current node. Therefore, we look on the right side of the current subtree if the value of the current node is lesser than the target, or the left side of the current subtree if the value of the current node is greater than the target. 

After we find the node we want to delete, we can expect one of three situations:
1. **The current node has no left child**, in which case we can connect its parent with its right child.
2. **The current node has no right child**, in which case we can connect its parent with its left child.
3. **The current node has both left and right children**, in which case we can connect its parent with either the smallest node on the right side or the greatest node on the left side. 

In the third case, we will need a helper function to find the node we want to replace the deleted node with. For as the binary search tree invariant implies, the smallest node on the right side will be greater than any node on the left side while being the smallest on the right side, and the greatest node on the left side will be smaller than any node on the right side while being the greatest on the left side. The time complexity of this solution is **O(log(n))**.

### Code
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 **/

const deleteNode = (root, key) => {
    if (root === null) return null;
    if (root.val === key) {
        if (!root.left) return root.right;
        if (!root.right) return root.left;
        let min = findMin(root.right);
        root.val = min.val;
        root.right = deleteNode(root.right, min.val);
    } else if (root.val < key) {
        root.right = deleteNode(root.right, key);
    } else if (root.val > key) {
        root.left = deleteNode(root.left, key);
    }
    
    return root;
};

const findMin = (node) => {
    while (node.left) {
        node = node.left;
    }
    
    return node;
};
```